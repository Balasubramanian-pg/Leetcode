# Finding Products with Exactly Three Consecutive Digits

## Overview

> [!NOTE]  
> This problem requires identifying product names containing exactly three consecutive digits, not part of a longer digit sequence.

## 1. Problem Description

### 1.1 Table Structure

> [!TIP]  
> The Products table contains product information with names that may include digit sequences.

```
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| product_id  | int     |
| name        | varchar |
+-------------+---------+
```

> [!IMPORTANT]  
> We need to precisely match sequences of exactly three digits, not more or less.

## 2. Solution Approach

### 2.1 Pattern Matching Concept

> [!TIP]  
> Using regular expressions allows us to identify digit sequences with specific boundary conditions.

> [!WARNING]  
> Must ensure sequences aren't part of longer digit strings (e.g., "1234" contains "123" but shouldn't match).

### 2.2 SQL Solution (MySQL & PostgreSQL)

```sql
SELECT product_id, name
FROM Products
WHERE name REGEXP '(^|[^0-9])[0-9]{3}($|[^0-9])'
ORDER BY product_id ASC;
```

> [!NOTE]  
> The regex pattern matches:
> - Start of string OR non-digit character
> - Exactly three digits
> - End of string OR non-digit character

## 3. Example Output

> [!EXAMPLE]  
> Correctly identifies products with exactly three consecutive digits.

```
+-------------+--------------------+
| product_id  | name               |
+-------------+--------------------+
| 1           | ABC123XYZ          |
| 5           | 789Product         |
| 6           | Item003Description |
+-------------+--------------------+
```

## 4. Alternative Approaches

### 4.1 Using POSIX Character Classes

```sql
-- PostgreSQL specific
SELECT product_id, name
FROM Products
WHERE name ~ '(^|[^[:digit:]])[[:digit:]]{3}($|[^[:digit:]])'
ORDER BY product_id;
```

### 4.2 Using Word Boundaries (Limited Usefulness)

```sql
-- MySQL with word boundaries (may not work as expected)
SELECT product_id, name
FROM Products
WHERE name REGEXP '[[:<:]][0-9]{3}[[:>:]]'
ORDER BY product_id;
```

## 5. Performance Considerations

> [!IMPORTANT]  
> For large tables:
> - Add a functional index on the regex pattern if supported
> - Consider materialized views for frequently queried patterns
> - Pre-filter with simpler conditions before applying regex

## 6. Common Mistakes

> [!CAUTION]  
> Using `[0-9]{3}` without boundary checks would incorrectly match longer digit sequences.

> [!WARNING]  
> Forgetting that digits at start/end of string need special handling in the pattern.

## 7. Real-World Application

> [!TIP]  
> Similar pattern matching is used for:
> - Product code validation
> - Serial number identification
> - Inventory management systems

## 8. Edge Cases

> [!NOTE]  
> The solution correctly handles:
> - Products with only three digits ("123")
> - Digits at start/end of name
> - Mixed alphanumeric patterns
> - Multiple three-digit sequences in one name

## 9. Pattern Explanation

The regex `(^|[^0-9])[0-9]{3}($|[^0-9])` breaks down as:
1. `(^|[^0-9])` - Start of string OR non-digit character
2. `[0-9]{3}` - Exactly three digits
3. `($|[^0-9])` - End of string OR non-digit character

This ensures the three digits are properly bounded and not part of a longer sequence.

# Inner Monologue

<SQL Solution>  
```sql  
SELECT product_id, name  
FROM Products  
WHERE name REGEXP '(^|[^0-9])[0-9]{3}($|[^0-9])'  
ORDER BY product_id ASC;  
```  
</SQL Solution>  

This solution uses a regular expression pattern to find products whose names contain exactly three consecutive digits that are not part of a longer sequence of digits. Let me explain how it works:

1. The `REGEXP` operator is used to perform pattern matching against the `name` column
2. The pattern `(^|[^0-9])[0-9]{3}($|[^0-9])` breaks down as follows:
    - `(^|[^0-9])`: Match either the start of the string (`^`) OR a non-digit character `[^0-9]`
    - `[0-9]{3}`: Match exactly three consecutive digit characters
    - `($|[^0-9])`: Match either the end of the string (`$`) OR a non-digit character `[^0-9]`

This pattern ensures that we match sequences that are:

- Exactly three digits long
- Either at the beginning of the string or preceded by a non-digit character
- Either at the end of the string or followed by a non-digit character

This prevents matching longer sequences of digits (like "56789" in "Product56789") while correctly identifying standalone three-digit sequences.

Tracing through the examples:

- "ABC123XYZ" matches because "123" is a sequence of three digits surrounded by non-digits
- "789Product" matches because "789" is a sequence of three digits at the start followed by a non-digit
- "Item003Description" matches because "003" is a sequence of three digits surrounded by non-digits
- "Product56789" doesn't match because "567", "678", and "789" are all part of a longer sequence of digits
- "A12B34C" doesn't match because it only has sequences of two digits
- "Product12X34" doesn't match for the same reason

The results are then ordered by product_id in ascending order as required.
