# Invalid Tweets Identification (Multiple Criteria)

## Overview

> [!NOTE]  
> This problem demonstrates advanced filtering with multiple conditions, including character length and pattern counting in SQL.

## 1. Problem Description

### 1.1 Table Structure

> [!TIP]  
> The Tweets table contains social media posts that need validation against multiple business rules.

```
+----------------+---------+
| Column Name    | Type    |
+----------------+---------+
| tweet_id       | int     |
| content        | varchar |
+----------------+---------+
```

> [!IMPORTANT]  
> Invalid tweets must meet ANY of three criteria: length >140, >3 mentions, or >3 hashtags.

## 2. Solution Approach

### 2.1 Multi-Condition Filtering Concept

> [!TIP]  
> We use a combination of string functions to evaluate each validation rule independently.

> [!WARNING]  
> The OR operator ensures a tweet is invalid if it fails ANY condition, not all.

### 2.2 SQL Solution (MySQL & PostgreSQL)

```sql
SELECT tweet_id
FROM Tweets
WHERE 
    -- Criterion 1: Length exceeds 140 characters
    CHAR_LENGTH(content) > 140
    
    -- Criterion 2: More than 3 mentions (@)
    OR (CHAR_LENGTH(content) - CHAR_LENGTH(REPLACE(content, '@', ''))) > 3
    
    -- Criterion 3: More than 3 hashtags (#)
    OR (CHAR_LENGTH(content) - CHAR_LENGTH(REPLACE(content, '#', ''))) > 3
    
ORDER BY tweet_id;
```

> [!NOTE]  
> CHAR_LENGTH ensures accurate character counting across both MySQL and PostgreSQL.

## 3. Example Output

> [!EXAMPLE]  
> The output correctly identifies tweets violating any of the criteria.

```
+----------+
| tweet_id |
+----------+
| 1        |  -- 4 mentions
| 4        |  -- 4 hashtags
+----------+
```

## 4. Alternative Approaches

### 4.1 Using REGEXP for Counting (PostgreSQL)

> [!TIP]  
> PostgreSQL's REGEXP_MATCHES provides more precise pattern counting.

```sql
-- PostgreSQL specific
SELECT tweet_id
FROM Tweets
WHERE 
    CHAR_LENGTH(content) > 140
    OR (SELECT COUNT(*) FROM REGEXP_MATCHES(content, '@\w+', 'g')) > 3
    OR (SELECT COUNT(*) FROM REGEXP_MATCHES(content, '#\w+', 'g')) > 3
ORDER BY tweet_id;
```

### 4.2 Using REGEXP_REPLACE (MySQL)

> [!NOTE]  
> MySQL's REGEXP_REPLACE can simplify the counting logic.

```sql
-- MySQL specific
SELECT tweet_id
FROM Tweets
WHERE 
    CHAR_LENGTH(content) > 140
    OR ((CHAR_LENGTH(content) - CHAR_LENGTH(REGEXP_REPLACE(content, '@[^ ]+', ''))) / CHAR_LENGTH('@x')) > 3
    OR ((CHAR_LENGTH(content) - CHAR_LENGTH(REGEXP_REPLACE(content, '#[^ ]+', ''))) / CHAR_LENGTH('#x')) > 3
ORDER BY tweet_id;
```

## 5. Performance Considerations

> [!IMPORTANT]  
> For large datasets:
> - Add computed columns for length, mention count, and hashtag count
> - Consider partial indexes for each validation criterion
> - Batch process in production systems

## 6. Common Mistakes

> [!CAUTION]  
> Using LENGTH instead of CHAR_LENGTH in MySQL (counts bytes, not characters)

> [!WARNING]  
> Forgetting that REPLACE counts all symbols, even invalid mentions/hashtags

## 7. Real-World Application

> [!TIP]  
> Similar validation is used in:
> - Social media moderation systems
> - Content management platforms
> - Marketing compliance tools

## 8. Edge Cases

> [!NOTE]  
> The solution handles:
> - Tweets with email addresses containing '@'
> - Hashtags/mentions at the start/end of content
> - Mixed case mentions (though problem states lowercase only)

## 9. Cross-Database Notes

### 9.1 MySQL Specifics

> [!TIP]  
> In MySQL, CHAR_LENGTH() is preferred over LENGTH() for character counting.

### 9.2 PostgreSQL Specifics

> [!NOTE]  
> PostgreSQL's regex functions are more powerful but have different syntax than MySQL.
